---
title: 数据类型与声明
date: 2018-11-05 17:50:55
tags: 
categories: 
- C++基础语法部分
- 基础
---

# 整型
## 一般整型
整形用于存储整数，C++所存储的整数是所有整数的一个子集。针对不同的区间，C++提供了多种不同的整形类型。具体如下所示：

|类型|位数|
|:--:|:--:|
|short|至少为16位|
|int|至少与short一样长|
|long|至少32位，且至少与int一样长|
|long long|至少64位，且至少与long一样长|

在上述变量声明中，在最开始加上unsigned，则为声明一个无符号数。此时它不能表示负数，但是正数的表示范围将扩大一倍
上述变量可由以下形式进行声明及初始化：

```
//变量声明方法
short a;
int b;
long c;
long long d;
unsigned d1; //声明无符号数
//变量声明与初始化
int e=5;
int f(123); //注意，该种初始化方式仅限于C++语言使用
int g=e+f;
int h={1};
int i{1}; //大括号的初始化方法通常用于数组和结构，但在C++中，也可以用于进行单值变量的初始化
```
**在C++中，默认使用十进制进行数字表示。但通过控制也可以输出其他进制的数字。**如在下面的程序段中，输出结果将为“2a”，也就是42的十六进制表示。

```
int chest=42;
cout<<hex;
cout<<chest;
```

## 字符类型
字符类型char也可以被当做是一种整形，是专门为了存储字符而设计的。在计算机中，这些字符由其ASCII码值进行保存。这里请注意，由于在char中保存的其实是字符的ASCII码值，因而保存的其实是一个整数，**故而对于整数的所有运算值对于char而言全部适用**。在输出时，cout会根据char类型，输出该数值对应的字符。如下所示：

```
char A;
cin>>A;
A=A+1;
cout<<A;
```

此时的输入输出将如下所示：

```
a
b
```

对于字符类型有一点需要特别注意，**即在初始化时，需要用单引号括住而不是双引号**。在C++中，单引号代表单个字符，而双引号则代表字符串，即末尾有结束符'\0'。具体如下：

```
char a='A'; //合法
char a="A"; //不合法，右侧等价于'A'+'\0'
```

## bool类型
bool类型是一种逻辑运算符，其值有两种形式，分别为true和false。在判断语句中，经常使用。**请注意，对于bool变量赋值时，所有非零值均会被转换为true，0则会被转换为false。**

```
bool is_ready=true; //定义布尔变量，初始化为true
int ans=true; //true被转化为整形时，值为1
int ans=false; //false被转化为整形时，值为0
bool start=-100; //非零值，为true
bool end=0; //初值为0，为false
```

# 浮点类型
与整型一样，浮点类型一般也有三种表示形式，float、double和long double。一般来讲，float的位数至少为32位，double的位数不小于float且至少为48位，而long double则要更长。
相比于整型，浮点类型可以表达的数字更大，但是其运算效率一般低于整型。同时，由于存在精度的问题，浮点类型的计算结果可能会出现偏差。

# C++基本算数运算
C++中的算术运算符可以总结如下：

|符号|作用|
|:--:|:--:|
|+|执行加法运算|
|-|执行减法运算|
|*|执行乘法运算|
|/|执行除法运算，若除号两边均为整数，则结果为商的整数部分|
|%|执行取余运算，请注意，该运算符两端必须均为整数|

# 类型转换
C++会在不同场合下，根据需要对值得类型进行转换
## 初始化和赋值间的转换

```
long int a=1;
short int b=2;
a=b; //b的值扩展为long int之后赋给a
```

## 表达式中的转换
在该种转换中，所有低等级的变量将自动被转换为高等级的变量，如short将会被自动转换为int。

## 强制类型转换
C++允许进行显式形式的强制类型转换，比如下面的表达：

```
(long) thorn;
thorn (long);
cout<<int('Q');
```

请注意，**上述转换中，并没有改变原先变量本身，而是创造出了一个新的、指定类型的值。**

## auto声明
C++中，可以使用auto进行声明与初始化，编译器会根据初始化结果给变量设定类型，举例如下：

```
auto n=100; //编译器定位整型
auto x=1.5; //编译器定为double
```

但是，该种定义方式并不提倡。
